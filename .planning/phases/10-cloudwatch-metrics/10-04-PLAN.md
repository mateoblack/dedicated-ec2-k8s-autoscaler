---
phase: 10-cloudwatch-metrics
plan: 04
type: execute
---

<objective>
Integrate bash metrics into bootstrap scripts and add custom metrics to CloudWatch dashboard.

Purpose: Complete the metrics implementation by adding operational metrics to bootstrap scripts and updating the monitoring dashboard to visualize the new custom metrics.
Output: Bootstrap scripts emitting metrics, monitoring-stack.ts dashboard showing custom metrics.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-cloudwatch-metrics/10-01-SUMMARY.md
@.planning/phases/10-cloudwatch-metrics/10-02-SUMMARY.md
@.planning/phases/10-cloudwatch-metrics/10-03-SUMMARY.md

# Bash metrics module:
@lib/scripts/bash-metrics.ts

# Bootstrap scripts to update:
@lib/scripts/control-plane-bootstrap.ts
@lib/scripts/worker-bootstrap.ts

# Monitoring dashboard:
@lib/monitoring-stack.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metrics to control-plane-bootstrap.ts</name>
  <files>lib/scripts/control-plane-bootstrap.ts</files>
  <action>
Update createControlPlaneBootstrapScript to emit metrics at key operation points:

1. Add import of getBashMetricsFunctions at top
2. Add ${getBashMetricsFunctions()} interpolation after logging functions (near line 150 where getBashRetryFunctions is)
3. Capture BOOTSTRAP_START_TIME at script start: `BOOTSTRAP_START_TIME=$(date +%s%3N)`
4. Add metrics at key points:

   At successful bootstrap completion (before final log):
   ```bash
   BOOTSTRAP_END_TIME=$(date +%s%3N)
   BOOTSTRAP_DURATION=$((BOOTSTRAP_END_TIME - BOOTSTRAP_START_TIME))
   emit_metric "BootstrapDuration" "$BOOTSTRAP_DURATION" "$METRIC_MILLISECONDS"
   emit_metric "BootstrapSuccess" "1" "$METRIC_COUNT"
   ```

   In cleanup_on_failure function (before exit):
   ```bash
   emit_metric "BootstrapFailure" "1" "$METRIC_COUNT"
   emit_metric_with_dimensions "BootstrapFailureStage" "1" "$METRIC_COUNT" "Name=Stage,Value=$BOOTSTRAP_STAGE"
   ```

   After successful etcd member registration (when ETCD_REGISTERED=true is set):
   ```bash
   emit_metric "EtcdMemberRegistered" "1" "$METRIC_COUNT"
   ```

   After successful LB registration (when LB_REGISTERED=true is set):
   ```bash
   emit_metric "LoadBalancerRegistered" "1" "$METRIC_COUNT"
   ```

IMPORTANT: Place emit_metric calls after the critical operation succeeds, not before. Use `|| true` suffix since metrics must not cause bootstrap failure.
  </action>
  <verify>Grep lib/scripts/control-plane-bootstrap.ts for "emit_metric" shows 5+ calls</verify>
  <done>Control plane bootstrap emits BootstrapDuration, Success/Failure, EtcdMemberRegistered, LBRegistered metrics</done>
</task>

<task type="auto">
  <name>Task 2: Add metrics to worker-bootstrap.ts</name>
  <files>lib/scripts/worker-bootstrap.ts</files>
  <action>
Update createWorkerBootstrapScript to emit metrics:

1. Add import of getBashMetricsFunctions at top
2. Add ${getBashMetricsFunctions()} interpolation after logging functions
3. Capture BOOTSTRAP_START_TIME at script start
4. Add metrics:

   At successful bootstrap completion:
   ```bash
   BOOTSTRAP_END_TIME=$(date +%s%3N)
   BOOTSTRAP_DURATION=$((BOOTSTRAP_END_TIME - BOOTSTRAP_START_TIME))
   emit_metric_with_dimensions "BootstrapDuration" "$BOOTSTRAP_DURATION" "$METRIC_MILLISECONDS" "Name=NodeType,Value=Worker"
   emit_metric_with_dimensions "BootstrapSuccess" "1" "$METRIC_COUNT" "Name=NodeType,Value=Worker"
   ```

   On bootstrap failure:
   ```bash
   emit_metric_with_dimensions "BootstrapFailure" "1" "$METRIC_COUNT" "Name=NodeType,Value=Worker"
   ```

Use NodeType dimension to distinguish worker metrics from control plane metrics.

IMPORTANT: Worker bootstrap is simpler than control plane, so fewer metric points needed. Focus on success/failure/duration.
  </action>
  <verify>Grep lib/scripts/worker-bootstrap.ts for "emit_metric" shows 3+ calls</verify>
  <done>Worker bootstrap emits BootstrapDuration, Success/Failure metrics with NodeType=Worker dimension</done>
</task>

<task type="auto">
  <name>Task 3: Add custom metrics to CloudWatch dashboard</name>
  <files>lib/monitoring-stack.ts</files>
  <action>
Update createDashboard method to include custom metrics widgets:

1. Add a new row after the Lambda Functions row (Row 4) titled "Custom Metrics":

```typescript
// Row 5: Custom Metrics (from Phase 10)
dashboard.addWidgets(
  new cloudwatch.GraphWidget({
    title: 'Bootstrap Operations',
    left: [
      new cloudwatch.Metric({
        namespace: `K8sCluster/${props.clusterName}`,
        metricName: 'BootstrapSuccess',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(1)
      }),
      new cloudwatch.Metric({
        namespace: `K8sCluster/${props.clusterName}`,
        metricName: 'BootstrapFailure',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(1)
      })
    ],
    width: 8,
    height: 6
  }),
  new cloudwatch.GraphWidget({
    title: 'etcd Operations',
    left: [
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdLifecycle',
        metricName: 'EtcdMemberRemovalSuccess',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(1)
      }),
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdLifecycle',
        metricName: 'EtcdMemberRemovalFailure',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(1)
      }),
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdBackup',
        metricName: 'BackupSuccess',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(6)
      })
    ],
    width: 8,
    height: 6
  }),
  new cloudwatch.GraphWidget({
    title: 'Cluster Health Metrics',
    left: [
      new cloudwatch.Metric({
        namespace: 'K8sCluster/Health',
        metricName: 'HealthyControlPlaneInstances',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Average',
        period: cdk.Duration.minutes(5)
      }),
      new cloudwatch.Metric({
        namespace: 'K8sCluster/Health',
        metricName: 'AutoRecoveryTriggered',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Sum',
        period: cdk.Duration.hours(1)
      })
    ],
    width: 8,
    height: 6
  })
);
```

2. Add a second row for duration metrics:

```typescript
// Row 6: Operation Durations
dashboard.addWidgets(
  new cloudwatch.GraphWidget({
    title: 'Bootstrap Duration',
    left: [
      new cloudwatch.Metric({
        namespace: `K8sCluster/${props.clusterName}`,
        metricName: 'BootstrapDuration',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Average',
        period: cdk.Duration.hours(1)
      })
    ],
    width: 8,
    height: 6
  }),
  new cloudwatch.GraphWidget({
    title: 'etcd Backup Size',
    left: [
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdBackup',
        metricName: 'BackupSizeBytes',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Average',
        period: cdk.Duration.hours(6)
      })
    ],
    width: 8,
    height: 6
  }),
  new cloudwatch.GraphWidget({
    title: 'Lambda Durations (Custom)',
    left: [
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdLifecycle',
        metricName: 'LifecycleHandlerDuration',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Average',
        period: cdk.Duration.hours(1)
      }),
      new cloudwatch.Metric({
        namespace: 'K8sCluster/EtcdBackup',
        metricName: 'BackupDuration',
        dimensionsMap: { ClusterName: props.clusterName },
        statistic: 'Average',
        period: cdk.Duration.hours(6)
      })
    ],
    width: 8,
    height: 6
  })
);
```

Note: Metrics won't appear in dashboard until first data points are emitted (after deployment and operations occur).
  </action>
  <verify>npm run test:code passes, grep monitoring-stack.ts for "K8sCluster/" shows custom namespace usage</verify>
  <done>Dashboard has 6 new widgets showing bootstrap, etcd, health, and duration metrics</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:code` passes (no regressions)
- [ ] grep for "emit_metric" in control-plane-bootstrap.ts shows 5+ calls
- [ ] grep for "emit_metric" in worker-bootstrap.ts shows 3+ calls
- [ ] grep for "K8sCluster" in monitoring-stack.ts shows custom namespaces
- [ ] Dashboard createDashboard method has 2 new rows of widgets
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Bootstrap scripts emit metrics at key operation points
- Dashboard visualizes custom metrics from Lambda and bootstrap
- Phase 10 complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-cloudwatch-metrics/10-04-SUMMARY.md` with:
- Summary: "Added CloudWatch custom metrics infrastructure with EMF for Lambda, PutMetricData for bash, and dashboard visualization"
- Note that Phase 10 is complete
</output>
