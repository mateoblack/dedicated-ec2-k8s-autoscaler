---
phase: 12-graceful-recovery
plan: 04
type: execute
---

<objective>
Add circuit breaker pattern to Python retry to stop retrying when a service is clearly down.

Purpose: When AWS services experience prolonged outages, continuing to retry wastes Lambda execution time and delays lifecycle hook completion. Circuit breaker fails fast after consecutive failures.
Output: New circuit_breaker_retry() function that tracks failure state and fails immediately when circuit is open.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase:
@.planning/phases/12-graceful-recovery/12-03-PLAN.md

# Key files:
@lib/scripts/python-retry.ts
@lib/scripts/etcd-lifecycle-lambda.ts

**Tech stack available:** TypeScript, Python 3.11, Jest
**Established patterns:** retry_with_backoff with jitter (from 12-03)
**Constraining decisions:**
- Phase 12-03: Added jitter to Python retry
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker class</name>
  <files>lib/scripts/python-retry.ts</files>
  <action>
Add CircuitBreaker class to python-retry.ts generated code.

```python
class CircuitBreaker:
    """
    Simple circuit breaker for fail-fast behavior during service outages.

    States:
    - CLOSED: Normal operation, requests pass through
    - OPEN: Service down, requests fail immediately
    - HALF_OPEN: Testing if service recovered

    Transitions:
    - CLOSED -> OPEN: After failure_threshold consecutive failures
    - OPEN -> HALF_OPEN: After reset_timeout seconds
    - HALF_OPEN -> CLOSED: On success
    - HALF_OPEN -> OPEN: On failure
    """

    def __init__(self, failure_threshold=5, reset_timeout=60):
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.failures = 0
        self.last_failure_time = None
        self.state = 'CLOSED'

    def can_execute(self):
        if self.state == 'CLOSED':
            return True
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time >= self.reset_timeout:
                self.state = 'HALF_OPEN'
                return True
            return False
        return True  # HALF_OPEN

    def record_success(self):
        self.failures = 0
        self.state = 'CLOSED'

    def record_failure(self):
        self.failures += 1
        self.last_failure_time = time.time()
        if self.failures >= self.failure_threshold:
            self.state = 'OPEN'
```

Export as part of getPythonRetryUtils() return string.
  </action>
  <verify>Grep for "class CircuitBreaker" in python-retry.ts</verify>
  <done>CircuitBreaker class with CLOSED/OPEN/HALF_OPEN states exists in generated code</done>
</task>

<task type="auto">
  <name>Task 2: Create retry_with_circuit_breaker function</name>
  <files>lib/scripts/python-retry.ts</files>
  <action>
Add retry_with_circuit_breaker() function that combines retry logic with circuit breaker.

```python
def retry_with_circuit_breaker(
    operation,
    operation_name,
    circuit_breaker,
    max_retries=3,
    base_delay=5,
    jitter_factor=0.3,
    retriable_exceptions=(Exception,)
):
    """
    Execute operation with retry logic protected by circuit breaker.

    If circuit is OPEN, fails immediately without attempting operation.
    Records success/failure to circuit breaker for state transitions.
    """
    if not circuit_breaker.can_execute():
        logger.warning(f"Circuit breaker OPEN for {operation_name}, failing fast")
        return None

    result = retry_with_backoff(
        operation,
        operation_name,
        max_retries=max_retries,
        base_delay=base_delay,
        jitter_factor=jitter_factor,
        retriable_exceptions=retriable_exceptions
    )

    if result is not None:
        circuit_breaker.record_success()
    else:
        circuit_breaker.record_failure()

    return result
```

Add to getPythonRetryUtils() return string after CircuitBreaker class.
  </action>
  <verify>Grep for "retry_with_circuit_breaker" in python-retry.ts</verify>
  <done>retry_with_circuit_breaker function wraps retry_with_backoff with circuit breaker checks</done>
</task>

<task type="auto">
  <name>Task 3: Add circuit breaker tests</name>
  <files>test/scripts/python-retry.test.ts</files>
  <action>
Add tests for circuit breaker implementation:
1. Test CircuitBreaker class is defined in generated code
2. Test retry_with_circuit_breaker function is defined
3. Test circuit breaker has failure_threshold and reset_timeout parameters
4. Test three states (CLOSED, OPEN, HALF_OPEN) are documented
5. Test can_execute, record_success, record_failure methods exist
  </action>
  <verify>Run `npm run test:code -- python-retry` to verify tests pass</verify>
  <done>Tests verify circuit breaker class and function are properly generated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:code` passes all tests
- [ ] CircuitBreaker class with three states
- [ ] retry_with_circuit_breaker function wraps retry_with_backoff
- [ ] State transitions documented
- [ ] No TypeScript errors
</verification>

<success_criteria>

- CircuitBreaker class with CLOSED/OPEN/HALF_OPEN states
- retry_with_circuit_breaker integrates circuit breaker with retry logic
- Tests verify implementation
- All existing tests pass
- Note: Lambda functions NOT updated to use circuit breaker yet (optional follow-up)
</success_criteria>

<output>
After completion, create `.planning/phases/12-graceful-recovery/12-04-SUMMARY.md`
</output>
