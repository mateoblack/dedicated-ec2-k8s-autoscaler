---
phase: 12-graceful-recovery
plan: 03
type: execute
---

<objective>
Add jitter to Python retry function for Lambda functions to prevent correlated retries.

Purpose: When multiple Lambda invocations (e.g., concurrent etcd lifecycle events) hit the same backend (SSM, EC2 API), synchronized retries cause API throttling. Jitter decorrelates retry timing.
Output: Enhanced retry_with_backoff() with configurable jitter factor.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase:
@.planning/phases/12-graceful-recovery/12-01-PLAN.md
@.planning/phases/12-graceful-recovery/12-02-PLAN.md

# Key files:
@lib/scripts/python-retry.ts

**Tech stack available:** TypeScript, Python 3.11, Jest
**Established patterns:** retry_with_backoff with exponential backoff, is_retriable attribute checking
**Constraining decisions:**
- Phase 12-01: Bash retry uses jitter factor of 0.3 (30%)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add jitter parameter to retry_with_backoff</name>
  <files>lib/scripts/python-retry.ts</files>
  <action>
Add jitter_factor parameter to retry_with_backoff() function.

New signature:
```python
def retry_with_backoff(
    operation,
    operation_name,
    max_retries=3,
    base_delay=5,
    jitter_factor=0.3,
    retriable_exceptions=(Exception,)
):
```

Implementation:
1. Add jitter_factor parameter with default 0.3 (matches bash)
2. Import random at top of generated code
3. Calculate jitter: `jitter = delay * jitter_factor * random.random()`
4. Apply to delay: `actual_delay = delay + jitter`
5. Update docstring to document jitter_factor
6. Log actual delay including jitter

Python jitter: `random.random()` gives [0, 1), multiply by delay * jitter_factor for [0, delay*0.3) range.
  </action>
  <verify>Grep for "jitter_factor" in python-retry.ts. Check random is imported.</verify>
  <done>retry_with_backoff includes jitter_factor parameter with random jitter calculation</done>
</task>

<task type="auto">
  <name>Task 2: Update Lambda functions to pass jitter_factor</name>
  <files>lib/scripts/etcd-lifecycle-lambda.ts, lib/scripts/etcd-backup-lambda.ts</files>
  <action>
Update retry_with_backoff calls in Lambda code to explicitly pass jitter_factor=0.3.

While the default is 0.3, explicit values document intent and allow future per-operation tuning.

In etcd-lifecycle-lambda.ts:
- Find retry_with_backoff calls (lines ~299, ~447)
- Add jitter_factor=0.3 to kwargs

In etcd-backup-lambda.ts:
- Find retry_with_backoff call (line ~73)
- Add jitter_factor=0.3 to kwargs

Note: cluster-health-lambda.ts does not use retry_with_backoff (it's read-only health checks).
  </action>
  <verify>Grep for "jitter_factor=0.3" in both Lambda files</verify>
  <done>Both etcd-lifecycle and etcd-backup Lambda functions explicitly specify jitter_factor</done>
</task>

<task type="auto">
  <name>Task 3: Add Python retry jitter tests</name>
  <files>test/scripts/python-retry.test.ts</files>
  <action>
Add tests for Python retry jitter:
1. Test jitter_factor parameter exists in function signature
2. Test random import is included in generated code
3. Test jitter calculation is present
4. Test default jitter_factor is 0.3

Create test file if it doesn't exist, following existing test patterns.
  </action>
  <verify>Run `npm run test:code -- python-retry` to verify tests pass</verify>
  <done>Tests verify Python retry jitter implementation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:code` passes all tests
- [ ] retry_with_backoff has jitter_factor parameter
- [ ] random is imported in generated Python code
- [ ] Lambda functions explicitly pass jitter_factor
- [ ] No TypeScript errors
</verification>

<success_criteria>

- Python retry function includes jitter calculation
- jitter_factor parameter documented with 0.3 default
- Lambda functions explicitly specify jitter_factor
- Tests verify implementation
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-graceful-recovery/12-03-SUMMARY.md`
</output>
