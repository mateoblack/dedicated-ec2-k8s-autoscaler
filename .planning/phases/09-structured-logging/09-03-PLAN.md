---
phase: 09-structured-logging
plan: 03
type: execute
---

<objective>
Create shared Python structured logging module for JSON log output in Lambda functions.

Purpose: Establish consistent JSON logging format for Lambda functions, enabling CloudWatch Logs Insights queries and structured monitoring.
Output: New `lib/scripts/python-logging.ts` module with JSON logging configuration that can be interpolated into Lambda code.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/scripts/python-retry.ts
@lib/scripts/index.ts

**Established patterns from prior phases:**
- Shared Python module pattern: TypeScript function returning Python code string
- getPythonRetryUtils() exported from python-retry.ts
- Lambda functions already use `logging.getLogger()` with INFO level

**Current logging:**
- Lambda functions use standard Python logger: `logger.info(f"message: {var}")`
- Output is plain text, not JSON structured
- Request ID available via `context.aws_request_id` but not consistently included
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create python-logging.ts module</name>
  <files>lib/scripts/python-logging.ts</files>
  <action>
Create new module with getPythonLoggingSetup() that returns Python code for JSON structured logging.

The code should:
1. Create a custom JSON formatter class
2. Configure the root logger to use JSON output
3. Include in every log record:
   - timestamp (ISO8601)
   - level
   - message
   - request_id (from Lambda context, set via a global)
   - function_name (from Lambda context)
   - Any extra fields passed to the logger

Python code structure:
```python
import json
import logging
from datetime import datetime

class JsonFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'level': record.levelname,
            'message': record.getMessage(),
            'logger': record.name,
            'request_id': getattr(record, 'request_id', _request_id),
            'function_name': getattr(record, 'function_name', _function_name),
        }
        # Include any extra fields
        if hasattr(record, 'extra'):
            log_record.update(record.extra)
        return json.dumps(log_record)

# Global context (set by handler)
_request_id = None
_function_name = None

def setup_logging(context=None):
    global _request_id, _function_name
    if context:
        _request_id = context.aws_request_id
        _function_name = context.function_name

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # Remove existing handlers and add JSON handler
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    logger.addHandler(handler)

    return logger
```

Requirements:
- Must be callable at start of Lambda handler: `setup_logging(context)`
- Should work with existing `logger.info()`, `logger.warning()`, etc. calls
- Support extra context via: `logger.info("message", extra={'key': 'value'})`
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>python-logging.ts exports getPythonLoggingSetup() and compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Export from scripts module and add unit test</name>
  <files>lib/scripts/index.ts, test/scripts/python-logging.test.ts</files>
  <action>
1. Add export for getPythonLoggingSetup to lib/scripts/index.ts

2. Create test file that verifies:
   - Function returns non-empty string
   - Output contains JsonFormatter class definition
   - Output contains setup_logging function
   - Output contains proper JSON structure patterns
   - Extra fields handling is present

Follow test patterns from existing python-retry tests if any exist.
  </action>
  <verify>`npm run test:code -- --testPathPattern=python-logging`</verify>
  <done>Tests pass, module is exported and usable</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run test:code -- --testPathPattern=python-logging` passes
- [ ] getPythonLoggingSetup() is exported from lib/scripts/index.ts
- [ ] Manual inspection: output contains valid Python logging setup
</verification>

<success_criteria>

- python-logging.ts module created with JSON formatter and setup function
- Formatter includes timestamp, level, message, request_id, function_name
- Module exported from lib/scripts/index.ts
- Unit tests verify code structure and patterns
</success_criteria>

<output>
After completion, create `.planning/phases/09-structured-logging/09-03-SUMMARY.md`
</output>
