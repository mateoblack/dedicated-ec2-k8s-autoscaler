---
phase: 02-retry-consolidation
plan: 02
type: execute
---

<objective>
Create shared Python retry utilities and update Lambda functions to use them.

Purpose: Consolidate duplicated Python retry logic from etcd-lifecycle-lambda and etcd-backup-lambda into a generic retry utility that handles exponential backoff and retriable exceptions.
Output: Shared python-retry.ts module, updated Lambda code generators using shared utilities.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase
@.planning/phases/02-retry-consolidation/02-01-SUMMARY.md

# Source files to modify
@lib/scripts/index.ts
@lib/scripts/etcd-lifecycle-lambda.ts
@lib/scripts/etcd-backup-lambda.ts

**Current Python retry patterns (duplicated):**

1. **etcd-lifecycle-lambda.ts** has two nearly identical retry wrappers:
   - `drain_node_with_retry()` (lines 216-250) - wraps `drain_node()`, handles NodeDrainError
   - `remove_etcd_member_with_retry()` (lines 372-406) - wraps `remove_etcd_member()`, handles EtcdRemovalError
   - Both use: exponential backoff, is_retriable check, MAX_RETRIES constant

2. **etcd-backup-lambda.ts** has inline retry loop:
   - Lines 53-62: for loop with linear backoff (attempt * delay instead of exponential)
   - Handles BackupError with is_retriable check

**Consolidation approach:**
Create a generic `retry_with_backoff(fn, max_retries, base_delay, retriable_exceptions)` decorator/function that:
- Takes a callable and exception types
- Implements exponential backoff (2^attempt * base_delay)
- Checks `is_retriable` attribute on exceptions
- Logs attempts and failures

**Tech context:**
- Lambda code is Python 3.11 generated as inline strings
- Exception classes have `is_retriable` attribute pattern
- Cannot use external packages - must be self-contained
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared Python retry utilities module</name>
  <files>lib/scripts/python-retry.ts</files>
  <action>Create new TypeScript file that exports `getPythonRetryUtils(): string`. The function returns a Python code string containing:

```python
def retry_with_backoff(
    operation,
    operation_name,
    max_retries=3,
    base_delay=5,
    retriable_exceptions=(Exception,)
):
    """
    Execute operation with exponential backoff retry logic.

    Args:
        operation: Callable to execute (no arguments - use closure or functools.partial)
        operation_name: Human-readable name for logging
        max_retries: Maximum number of attempts
        base_delay: Base delay in seconds (exponential: base_delay * 2^attempt)
        retriable_exceptions: Tuple of exception types to catch and retry

    Returns:
        Result of operation() on success, or None on failure

    Raises:
        The last exception if operation fails all retries and caller needs it
    """
    last_error = None

    for attempt in range(1, max_retries + 1):
        try:
            logger.info(f"Attempt {attempt}/{max_retries}: {operation_name}")
            return operation()
        except retriable_exceptions as e:
            last_error = e
            is_retriable = getattr(e, 'is_retriable', True)
            logger.warning(f"{operation_name} attempt {attempt} failed: {str(e)}")

            if not is_retriable:
                logger.error(f"{operation_name} error is not retriable, giving up")
                break

            if attempt < max_retries:
                delay = base_delay * (2 ** (attempt - 1))
                logger.info(f"Waiting {delay}s before retry...")
                time.sleep(delay)
        except Exception as e:
            last_error = e
            logger.error(f"Unexpected error in {operation_name} on attempt {attempt}: {str(e)}")
            if attempt < max_retries:
                time.sleep(base_delay)

    logger.error(f"All {max_retries} attempts failed for {operation_name}. Last error: {str(last_error)}")
    return None
```

Add JSDoc comment explaining this is a shared module for Python Lambda retry logic.

Note: The function returns None on failure (not raises) to match current pattern where callers check return value.</action>
  <verify>npx tsc --noEmit passes, file exists with exported function</verify>
  <done>lib/scripts/python-retry.ts exists with getPythonRetryUtils export, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Update etcd-lifecycle-lambda.ts to use shared retry</name>
  <files>lib/scripts/etcd-lifecycle-lambda.ts</files>
  <action>1. Add import: `import { getPythonRetryUtils } from './python-retry';`

2. In createEtcdLifecycleLambdaCode function, insert shared utilities after the exception class definitions (after line 44):
   `${getPythonRetryUtils()}`

3. Replace `drain_node_with_retry()` function (lines 216-250) with a wrapper that uses the shared utility:
```python
def drain_node_with_retry(node_name, terminating_instance_id):
    """Attempt to drain node with retries."""
    result = retry_with_backoff(
        lambda: drain_node(node_name, terminating_instance_id) or True,
        f"drain node {node_name}",
        max_retries=MAX_RETRIES,
        base_delay=RETRY_DELAY_SECONDS,
        retriable_exceptions=(NodeDrainError,)
    )
    return result is not None
```

4. Replace `remove_etcd_member_with_retry()` function (lines 372-406) similarly:
```python
def remove_etcd_member_with_retry(member_id, private_ip, terminating_instance_id):
    """Attempt to remove etcd member with retries."""
    result = retry_with_backoff(
        lambda: remove_etcd_member(member_id, private_ip, terminating_instance_id) or True,
        f"remove etcd member {member_id}",
        max_retries=MAX_RETRIES,
        base_delay=RETRY_DELAY_SECONDS,
        retriable_exceptions=(EtcdRemovalError,)
    )
    return result is not None
```

5. Ensure the retry logic behavior is preserved: returns True on success, False on failure.</action>
  <verify>npx tsc --noEmit passes, npm test -- --testPathPattern="compute|lifecycle" passes</verify>
  <done>etcd-lifecycle-lambda.ts uses shared retry utility, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Update etcd-backup-lambda.ts to use shared retry</name>
  <files>lib/scripts/etcd-backup-lambda.ts</files>
  <action>1. Add import: `import { getPythonRetryUtils } from './python-retry';`

2. In createEtcdBackupLambdaCode function, insert shared utilities after the BackupError exception class definition:
   `${getPythonRetryUtils()}`

3. Replace the inline retry loop in the handler (lines 52-62) with shared utility usage:

Current code:
```python
for attempt in range(1, MAX_RETRIES + 1):
    try:
        backup_key = create_etcd_backup(target_instance)
        ...
    except BackupError as e:
        ...
```

Replace with:
```python
backup_key = retry_with_backoff(
    lambda: create_etcd_backup(target_instance),
    "create etcd backup",
    max_retries=MAX_RETRIES,
    base_delay=RETRY_DELAY_SECONDS,
    retriable_exceptions=(BackupError,)
)

if backup_key:
    logger.info(f"Backup completed successfully: {backup_key}")
    return {'statusCode': 200, 'body': f'Backup created: {backup_key}'}
else:
    return {'statusCode': 500, 'body': 'Backup failed after all retries'}
```

Note: This changes from linear to exponential backoff - verify this is acceptable (exponential is safer for retries).</action>
  <verify>npx tsc --noEmit passes, npm test -- --testPathPattern="compute|backup" passes</verify>
  <done>etcd-backup-lambda.ts uses shared retry utility with exponential backoff, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `npm test` passes all 30 test suites
- [ ] `grep -c "retry_with_backoff" lib/scripts/python-retry.ts` returns 1 (defined in shared module)
- [ ] `grep -c "retry_with_backoff" lib/scripts/etcd-lifecycle-lambda.ts` returns 2+ (usages)
- [ ] `grep -c "retry_with_backoff" lib/scripts/etcd-backup-lambda.ts` returns 1+ (usage)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Python retry logic defined in exactly one location (python-retry.ts)
- All Lambda code generators use the shared module
- Exponential backoff consistently applied
- No test failures or TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-retry-consolidation/02-02-SUMMARY.md`:

# Phase 2 Plan 02: Python Retry Module Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `lib/scripts/python-retry.ts` - Created shared Python retry utilities module
- `lib/scripts/etcd-lifecycle-lambda.ts` - Updated to use shared retry
- `lib/scripts/etcd-backup-lambda.ts` - Updated to use shared retry

## Decisions Made

[Any decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 2 complete, ready for Phase 3: Variable Scoping Fix
</output>
