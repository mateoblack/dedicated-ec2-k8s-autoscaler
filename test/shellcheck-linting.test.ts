/**
 * Shell script linting tests using shellcheck.
 *
 * This module tests all bash scripts generated by the bootstrap generators
 * for shell scripting best practices and potential bugs.
 *
 * Excluded shellcheck rules:
 * - SC1091: Can't follow non-constant source (we don't source external files)
 * - SC2034: Unused variables (some vars used by embedded Python or later sections)
 * - SC2154: Referenced but not assigned (vars come from CDK interpolation like ${clusterName})
 */

import * as childProcess from 'child_process';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import * as cdk from 'aws-cdk-lib';

import { getBashRetryFunctions } from '../lib/scripts/bash-retry';
import { createControlPlaneBootstrapScript } from '../lib/scripts/control-plane-bootstrap';
import { createWorkerBootstrapScript } from '../lib/scripts/worker-bootstrap';

// Shellcheck issue interface for JSON output parsing
interface ShellcheckIssue {
  file: string;
  line: number;
  endLine: number;
  column: number;
  endColumn: number;
  level: 'error' | 'warning' | 'info' | 'style';
  code: number;
  message: string;
  fix: null | { replacements: unknown[] };
}

// Path to shellcheck binary from npm package
const SHELLCHECK_BIN = path.join(__dirname, '..', 'node_modules', '.bin', 'shellcheck');

// Helper function to run shellcheck on a script string
async function runShellcheck(script: string, name: string): Promise<ShellcheckIssue[]> {
  const tmpFile = path.join(os.tmpdir(), `shellcheck-${name}-${Date.now()}.sh`);

  // Write script to temp file
  fs.writeFileSync(tmpFile, script);

  try {
    // Run shellcheck with JSON output
    const result = await new Promise<ShellcheckIssue[]>((resolve, reject) => {
      childProcess.execFile(
        SHELLCHECK_BIN,
        [
          '--shell=bash',
          '--format=json',
          '--exclude=SC1091,SC2034,SC2154',
          tmpFile,
        ],
        { maxBuffer: 10 * 1024 * 1024 }, // 10MB buffer for large scripts
        (error, stdout, stderr) => {
          // shellcheck returns exit code 1 when issues are found
          // Only reject on actual execution errors
          if (error && !stdout) {
            reject(new Error(`shellcheck failed: ${stderr || error.message}`));
            return;
          }

          const output = stdout.toString().trim();
          if (!output) {
            resolve([]);
            return;
          }

          // The shellcheck npm wrapper may output INFO lines before JSON
          // Find the JSON array in the output (starts with '[' and ends with ']')
          const jsonMatch = output.match(/\[[\s\S]*\]$/);
          if (!jsonMatch) {
            // No JSON found - might be just INFO output with no issues
            if (output.includes('[INFO ]')) {
              resolve([]);
              return;
            }
            reject(new Error(`Failed to parse shellcheck output: ${output}`));
            return;
          }

          try {
            const issues: ShellcheckIssue[] = JSON.parse(jsonMatch[0]);
            resolve(issues);
          } catch (parseError) {
            reject(new Error(`Failed to parse shellcheck JSON: ${jsonMatch[0]}`));
          }
        }
      );
    });
    return result;
  } finally {
    // Clean up temp file
    if (fs.existsSync(tmpFile)) {
      fs.unlinkSync(tmpFile);
    }
  }
}

// Format issues for test output
function formatIssues(issues: ShellcheckIssue[]): string {
  return issues
    .map((issue) => `  SC${issue.code} (${issue.level}) line ${issue.line}: ${issue.message}`)
    .join('\n');
}

describe('Shell Script Linting', () => {
  let mockStack: cdk.Stack;

  beforeAll(() => {
    const app = new cdk.App();
    mockStack = new cdk.Stack(app, 'TestStack', {
      env: { account: '123456789012', region: 'us-west-2' },
    });
  });

  describe('bash-retry', () => {
    test('passes shellcheck', async () => {
      // getBashRetryFunctions returns just the functions, needs a wrapper script
      const script = `#!/bin/bash
MAX_RETRIES=5
RETRY_DELAY=5
${getBashRetryFunctions()}
# Test usage
retry_command echo "test"
`;

      const issues = await runShellcheck(script, 'bash-retry');

      expect(issues).toEqual([]);
    }, 30000);
  });

  describe('control-plane-bootstrap', () => {
    test('passes shellcheck', async () => {
      const script = createControlPlaneBootstrapScript(
        'test-cluster',
        'arn:aws:iam::123456789012:oidc-provider/s3.us-west-2.amazonaws.com/test-oidc',
        'test-oidc-bucket',
        'test-etcd-backup-bucket',
        mockStack
      );

      // Add shebang for shellcheck (scripts are embedded in userdata without shebang)
      const fullScript = `#!/bin/bash\n${script}`;

      const issues = await runShellcheck(fullScript, 'control-plane-bootstrap');

      if (issues.length > 0) {
        throw new Error(`shellcheck found ${issues.length} issue(s):\n${formatIssues(issues)}`);
      }
    }, 30000);
  });

  describe('worker-bootstrap', () => {
    test('passes shellcheck', async () => {
      const script = createWorkerBootstrapScript('test-cluster', mockStack);

      // Add shebang for shellcheck
      const fullScript = `#!/bin/bash\n${script}`;

      const issues = await runShellcheck(fullScript, 'worker-bootstrap');

      if (issues.length > 0) {
        throw new Error(`shellcheck found ${issues.length} issue(s):\n${formatIssues(issues)}`);
      }
    }, 30000);
  });
});
